max <- max(abs(map_data$delta_white), abs(map_data$delta_nonwhite))
absolute_pal <- colorNumeric(
palette = "PiYG",
domain = c(-max,max)
)
final_map <- leaflet(map_data) %>%
addProviderTiles(provider = providers$CartoDB.Positron) %>%
addPolygons(
fillColor = ~absolute_pal(delta_white),
label = ~round(delta_white),
color = "grey",
opacity = 0.5,
fillOpacity = 0.75,
weight = 1,
group = "White"
) %>%
addPolygons(
fillColor = ~absolute_pal(delta_nonwhite),
label = ~round(delta_nonwhite),
color = "grey",
opacity = 0.5,
fillOpacity = 0.75,
weight = 1,
group = "Non-White"
) %>%
addLegend(
pal = absolute_pal,
value = c(-max,max),
title = "Change in Population 2010-2020 (per acre)"
) %>%
addLayersControl(
baseGroups = c("White","Non-White"),
options = layersControlOptions(
collapsed = F
)
)
# Chunk 1: setup
knitr::opts_chunk$set(echo = F, message = F, warning = F)
# Chunk 2: libraries
library(tidyverse)
library(sf)
library(tigris)
library(mapview)
library(leaflet)
library(censusapi)
Sys.setenv(CENSUS_KEY="dbcdeeed2f9e907f31811ee78c1f239a2aa77934")
# Chunk 3: GeomData2020
# retrieving geometry for Mountain View Place for 2020
mv_place_2020 <- places("CA", year = 2020, progress_bar = F) %>%
filter(NAMELSAD %in% "Mountain View city")
scc_blocks_2020 <- blocks("CA", "Santa Clara", year = 2020, progress_bar = F)%>%
select(GEOID20, geometry)
scc_blocks_2010 <- blocks("CA", "Santa Clara", year = 2010, progress_bar = F)%>%
select(GEOID10, geometry)
# Retaining only blocks with centroids in city boundary, not exact but mostly accurate
mv_blocks_10 <-
scc_blocks_2010 %>%
st_centroid() %>%
.[mv_place_2020, ] %>%
st_set_geometry(NULL) %>%
left_join(scc_blocks_2010 %>% select(GEOID10)) %>%
st_as_sf()
# Chunk 4: CensusData2020
# getting associated census data
dec_vars_2020 <-
listCensusMetadata(
name = "2020/dec/pl",
type = "variables"
)
scc_pop_race_2020 <-
getCensus(
name = "dec/pl", vintage = 2020, region = "block:*",
regionin = "state:06+county:085", vars = "group(P1)") %>%
mutate(
block = paste0(state,county,tract,block)) %>%
select(
!c(GEO_ID,state,county,tract,NAME) & !ends_with(c("NA"))) %>%
pivot_longer(
ends_with("N"), names_to = "name", values_to = "estimate") %>%
left_join(
dec_vars_2020 %>%
select(name, label)) %>%
select(-name) %>%
separate(
label, into = c(NA,NA,"category1","category2"), sep = "!!") %>%
mutate(
race = case_when(
category1 == "Population of two or more races:" & is.na(category2) ~ "Two or more races",
category1 == "Population of two or more races:" ~ "",
!is.na(category2) ~ category2,
TRUE ~ ""
))%>%
filter(race != "") %>%
select(GEOID20 = block, race, pop20 = estimate)
# separate into non-white population and white population
pop20_nw <-
scc_pop_race_2020 %>%
filter(race %in% c(
"Black or African American alone",
"American Indian and Alaska Native alone",
"Asian alone",
"Native Hawaiian and Other Pacific Islander alone",
"Some Other Race alone",
"Two or more races")) %>%
group_by(GEOID20) %>%
summarize(pop_20_nw = sum(pop20, na.rm = T))
pop20_w <-
scc_pop_race_2020 %>%
filter(race %in% "White alone") %>%
group_by(GEOID20) %>%
summarize(pop_20_w = sum(pop20, na.rm = T))
pop_20 <- left_join(pop20_nw, pop20_w)
# removing repetitive data to clean up environment
rm(pop20_nw, pop20_w)
# Chunk 5: CensusData2010
# getting associated census data
dec_vars_2010 <-
listCensusMetadata(
name = "2010/dec/pl",
type = "variables"
)
scc_pop_race_2010 <-
getCensus(
name = "dec/pl", vintage = 2010, region = "block:*",
regionin = "state:06+county:085", vars = "group(P1)") %>%
mutate(
block = paste0(state,county,tract,block)) %>%
select(
!c(GEO_ID,state,county,tract,NAME) ) %>%
pivot_longer(
starts_with("P001"), names_to = "name", values_to = "estimate") %>%
left_join(
dec_vars_2010 %>%
select(name, label)) %>%
select(-name) %>%
separate(
label, into = c(NA,"category1","category2"), sep = "!!") %>%
mutate(
race = case_when(
category1 == "Two or More Races" & is.na(category2) ~ "Two or more races",
category1 == "Two or More Races" ~ "",
!is.na(category2) ~ category2,
TRUE ~ ""
))%>%
filter(race != "") %>%
select(GEOID10 = block, race, pop10 = estimate)
# separate into non-white population and white population
pop10_nw <-
scc_pop_race_2010 %>%
filter(race %in% c(
"Black or African American alone",
"American Indian and Alaska Native alone",
"Asian alone",
"Native Hawaiian and Other Pacific Islander alone",
"Some Other Race alone",
"Two or more races")) %>%
group_by(GEOID10) %>%
summarize(pop_10_nw = sum(pop10, na.rm = T))
pop10_w <-
scc_pop_race_2010 %>%
filter(race %in% "White alone") %>%
group_by(GEOID10) %>%
summarize(pop_10_w = sum(pop10, na.rm = T))
pop_10 <- left_join(pop10_nw, pop10_w)
# removing repetitive data to clean up environment
rm(pop10_nw, pop10_w)
# Chunk 6: Subsetting
# selecting 2020 blocks that intersect 2010 blocks
mv_blocks_20 <- scc_blocks_2020 %>%
.[mv_place_2020, ] %>%
left_join(pop_20) %>%
filter(!is.na(pop_20_nw))
mv_blocks_20_intersect <- mv_blocks_20 %>%
st_transform(26910) %>%
mutate(original_area = st_area(.)) %>%
st_intersection(
mv_blocks_10 %>%
st_transform(26910)
) %>%
mutate(
leftover_area = st_area(.),
perc_area_nw = as.numeric(pop_20_nw / original_area),
pop_20_c_nw = perc_area_nw * leftover_area,
perc_area_w = as.numeric(pop_20_w / original_area),
pop_20_c_w = perc_area_w * leftover_area
)
# sum areas by 2010 geoids to get 2020 pop in 2012 blocks
pop_20_b10 <-
mv_blocks_20_intersect %>%
group_by(GEOID10) %>%
summarize(
pop_20_nw = as.numeric(sum(pop_20_c_nw)),
pop_20_w = as.numeric(sum(pop_20_c_w))
) %>%
st_set_geometry(NULL) %>%
select(GEOID10,pop_20_nw,pop_20_w)
# Chunk 7: CombineData
map_data <-
mv_blocks_10 %>%
left_join(pop_20_b10) %>%
left_join(pop_10) %>%
mutate(
area = as.numeric(st_area(.)) * 0.000247105,  # get area in m^2 convert to acre
delta_white = (pop_20_w - pop_10_w) / area,
delta_nonwhite = (pop_20_nw - pop_10_nw) / area
)%>%
select( -c("pop_20_nw","pop_20_w","pop_10_nw","pop_10_w","area"))
# Chunk 8: mapping
#set color pallet
max <- max(abs(map_data$delta_white), abs(map_data$delta_nonwhite))
absolute_pal <- colorNumeric(
palette = "PiYG",
domain = c(-max,max)
)
final_map <- leaflet(map_data) %>%
addProviderTiles(provider = providers$CartoDB.Positron) %>%
addPolygons(
fillColor = ~absolute_pal(delta_white),
label = ~round(delta_white),
color = "grey",
opacity = 0.5,
fillOpacity = 0.75,
weight = 1,
group = "White"
) %>%
addPolygons(
fillColor = ~absolute_pal(delta_nonwhite),
label = ~round(delta_nonwhite),
color = "grey",
opacity = 0.5,
fillOpacity = 0.75,
weight = 1,
group = "Non-White"
) %>%
addLegend(
pal = absolute_pal,
value = c(-max,max),
title = "Change in Population 2010-2020 (per acre)"
) %>%
addLayersControl(
baseGroups = c("White","Non-White"),
options = layersControlOptions(
collapsed = F
)
)
# Chunk 9
# Chunk 10
final_map
# Chunk 11
map_data[11:20, ]
# Chunk 12: read data
park_data <- read_csv("data/NaturalElementsSpatialAnalysis - TractData_OverwroteNAs.csv")
t2_tracts_all <- filter(park_data, time == 2) %>% select(prolific_ID, time, tract)
t3_tracts_all <- filter(park_data, time == 3) %>% select(prolific_ID, time, tract)
t2_tracts_park <- filter(park_data, time == 2 & !is.na(propPark)) %>% select(prolific_ID, time, tract)
t3_tracts_park <- filter(park_data, time == 3 & !is.na(propPark)) %>% select(prolific_ID, time, tract)
# us_tracts_20 <- tracts(state = NULL, cb = TRUE) %>% rename(tract = GEOID)
# write_rds(us_tracts_20, file = "data/us_tracts_20.rds")
us_tracts_20 <- read_rds( file = "data/us_tracts_20.rds")
# Chunk 13: compile with geospatial data
t2_tracts_mapping <- t2_tracts_all %>%
left_join(us_tracts_20)%>%
st_as_sf()
t2_tracts_park_mapping <- t2_tracts_park %>%
left_join(us_tracts_20)%>%
st_as_sf()
t3_tracts_mapping <- t3_tracts_all %>%
left_join(us_tracts_20)%>%
st_as_sf()
t3_tracts_park_mapping <- t3_tracts_park %>%
left_join(us_tracts_20)%>%
st_as_sf()
# Chunk 14: map
tracts_of_interest <- leaflet(t2_tracts_mapping) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addPolygons(
data = t2_tracts_mapping,
color = "green",
opacity = 1,
weight = 2,
fill = F
)
tracts_of_interest
# Chunk 1: setup
knitr::opts_chunk$set(echo = F, message = F, warning = F)
# Chunk 2: libraries
library(tidyverse)
library(sf)
library(tigris)
library(mapview)
library(leaflet)
library(censusapi)
Sys.setenv(CENSUS_KEY="dbcdeeed2f9e907f31811ee78c1f239a2aa77934")
# Chunk 4: DataLoad
# Chunk 5: PUMAs
# identifying PUMAs in bay area
ca_pumas <-
pumas("CA", cb = T, progress_bar = F)
bay_county_names <-
c(
"Alameda",
"Contra Costa",
"Marin",
"Napa",
"San Francisco",
"San Mateo",
"Santa Clara",
"Solano",
"Sonoma"
)
bay_counties <-
counties("CA", cb = T, progress_bar = F) %>%
filter(NAME %in% bay_county_names)
bay_pumas <-
ca_pumas %>%
st_centroid() %>%
.[bay_counties, ] %>%
st_drop_geometry() %>%
left_join(ca_pumas %>% select(GEOID10)) %>%
st_as_sf()
bay_pums <-
pums_2019_1yr %>%
mutate(
PUMA = str_pad(public_use_microdata_area,5,"left","0")
) %>%
filter(PUMA %in% bay_pumas$PUMACE10)
# Chunk 6: DataManipulation
bay_pums_RaceInc <-
bay_pums %>%
mutate(
PWGTP = as.numeric(PWGTP),
nonwhite_lowinc = ifelse(
(RAC1P != 1) &
(HINCP < 80000),
PWGTP,
0
)
) %>%
group_by(PUMA) %>%
summarize(
perc_nonwhite_lowinc =
sum(nonwhite_lowinc, na.rm =T)/sum(PWGTP, na.rm = T)*100,
pop_atrisk = sum(nonwhite_lowinc, na.rm =T),
pop_total = sum(PWGTP, na.rm = T)
) %>%
left_join(
bay_pumas %>%
select(PUMACE10),
by = c("PUMA" = "PUMACE10")
) %>%
st_as_sf()
total_atrisk <- sum(bay_pums_RaceInc$pop_atrisk)
total_pop <- sum(bay_pums_RaceInc$pop_total)
# Chunk 7: mapping
pums_pal <- colorNumeric(
palette = "Purples",
domain = bay_pums_RaceInc$perc_nonwhite_renter_lowinc
)
map <- leaflet() %>%
addTiles() %>%
addPolygons(
data = bay_pums_RaceInc,
fillColor = ~pums_pal(perc_nonwhite_lowinc),
color = "white",
opacity = 0.5,
fillOpacity = 0.5,
weight = 1,
label = ~paste0(
round(perc_nonwhite_lowinc),
"% non-White populations from households making less than $80K"
),
highlightOptions = highlightOptions(
weight = 2,
opacity = 1
)
) %>%
addLegend(
data = bay_pums_RaceInc,
pal = pums_pal,
values = ~perc_nonwhite_lowinc,
title = "% non-White populations<br>from households<br>making less than $100K"
)
# Chunk 8
# Chunk 9
# Chunk 10
map
bay_pums_RaceInc <-
bay_pums %>%
mutate(
PWGTP = as.numeric(PWGTP),
nonwhite_lowinc = ifelse(
(RAC1P != 1) &
(HINCP < 80000),
PWGTP,
0
)
) %>%
group_by(PUMA) %>%
summarize(
perc_nonwhite_lowinc =
sum(nonwhite_lowinc, na.rm =T)/sum(PWGTP, na.rm = T)*100,
pop_atrisk = sum(nonwhite_lowinc, na.rm =T),
pop_total = sum(PWGTP, na.rm = T)
) %>%
left_join(
bay_pumas %>%
select(PUMACE10),
by = c("PUMA" = "PUMACE10")
) %>%
st_as_sf()
total_atrisk <- sum(bay_pums_RaceInc$pop_atrisk)
total_pop <- sum(bay_pums_RaceInc$pop_total)
library(tidyverse)
library(sf)
library(tigris)
library(mapview)
library(leaflet)
library(censusapi)
Sys.setenv(CENSUS_KEY="dbcdeeed2f9e907f31811ee78c1f239a2aa77934")
# retrieving PUMS data for CA, interested in household incomes and race
# sometimes this section runs and sometimes it doesn't, does not seem to be due to a code error though since the exact same chunk of code returns info sometimes and does not others. I did end up saving down a version of the data from a successful run to use when it is not working
pums_2019_1yr <- getCensus(
name = "acs/acs1/pums",
vintage = 2019,
region = "public use microdata area:*",
regionin = "state:06",
vars = c(
"SERIALNO",
"SPORDER",
"PWGTP",
"WGTP",
"NP",
"RAC1P",
"HINCP"
)
)
# identifying PUMAs in bay area
ca_pumas <-
pumas("CA", cb = T, progress_bar = F)
bay_county_names <-
c(
"Alameda",
"Contra Costa",
"Marin",
"Napa",
"San Francisco",
"San Mateo",
"Santa Clara",
"Solano",
"Sonoma"
)
bay_counties <-
counties("CA", cb = T, progress_bar = F) %>%
filter(NAME %in% bay_county_names)
bay_pumas <-
ca_pumas %>%
st_centroid() %>%
.[bay_counties, ] %>%
st_drop_geometry() %>%
left_join(ca_pumas %>% select(GEOID10)) %>%
st_as_sf()
bay_pums <-
pums_2019_1yr %>%
mutate(
PUMA = str_pad(public_use_microdata_area,5,"left","0")
) %>%
filter(PUMA %in% bay_pumas$PUMACE10)
ca_pumas <-
pumas("CA", cb = T, progress_bar = F)
ca_pumas <-
pumas("CA", cb = T, progress_bar = F)
# Chunk 1: setup
knitr::opts_chunk$set(echo = F, warning = F, message = F)
# Chunk 2: libraries
library(tidyverse)
library(tigris)
library(stringr)
library(sf)
Sys.setenv(CENSUS_KEY="dbcdeeed2f9e907f31811ee78c1f239a2aa77934")
# Chunk 3: read data
park_data <- read_csv("data/NaturalElementsSpatialAnalysis - TractData_OverwroteNAs.csv")
t2_tracts_all <- filter(park_data, time == 2) %>% select(prolific_ID, time, tract)
t3_tracts_all <- filter(park_data, time == 3) %>% select(prolific_ID, time, tract)
t2_tracts_park <- filter(park_data, time == 2 & !is.na(propPark)) %>% select(prolific_ID, time, tract)
t3_tracts_park <- filter(park_data, time == 3 & !is.na(propPark)) %>% select(prolific_ID, time, tract)
# us_tracts_20 <- tracts(state = NULL, cb = TRUE) %>% rename(tract = GEOID)
# write_rds(us_tracts_20, file = "data/us_tracts_20.rds")
us_tracts_20 <- read_rds( file = "data/us_tracts_20.rds")
# Chunk 4: compile with geospatial data
t2_tracts_mapping <- t2_tracts_all %>%
left_join(us_tracts_20)%>%
st_as_sf()
t2_tracts_park_mapping <- t2_tracts_park %>%
left_join(us_tracts_20)%>%
st_as_sf()
t3_tracts_mapping <- t3_tracts_all %>%
left_join(us_tracts_20)%>%
st_as_sf()
t3_tracts_park_mapping <- t3_tracts_park %>%
left_join(us_tracts_20)%>%
st_as_sf()
# Chunk 5: map
tracts_of_interest <- leaflet(t2_tracts_mapping) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addPolygons(
data = t2_tracts_mapping,
color = "green",
opacity = 1,
weight = 2,
fill = F
)
tracts_of_interest
